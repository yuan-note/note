# -*- mode: org; -*-

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css"/>

#+HTML_HEAD: <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.4/js/bootstrap.min.js"></script>
# #+HTML_HEAD: <script type="text/javascript" src="readtheorg/js/jquery.stickytableheaders.js"></script> // www.pirilamp.org/styles/lib/js/jquery.stickytableheaders.js 404 Now
#+HTML_HEAD: <script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-table-headers/0.1.19/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
#+HTML_HEAD: <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/languages/lisp.min.js"></script>
#+HTML_HEAD: <script>hljs.initHighlightingOnLoad();</script>

#+AUTHOR: 张园园
#+CREATOR: 张园园
#+TITLE: 我的笔记
#+EMAIL: zhyyituse@163.com
#+OPTIONS: toc:3 num:nil
#+STARTUP: showall


* Emacs
** 编程入门
*** 列表处理
    - 在lisp中，所有用双引号括起来的文本，包括标点符号和空格，都是单个原子。
    - 任何列表都是一个准备运行的程序。
    - “'” 被称作一个引用（quote）,当单引号位于一个列表之前时，它告诉lisp不要对这个列表做任何操作，仅仅是按其原样，但是如何一个列表前面没有引号，这个列表中的第一个符号就是一条计算机要执行的命令（在lisp中，这些命令被称作函数）
    #+BEGIN_SRC elisp

(+ 2 2)

'(this is a quoted list)

(substring "The quick brown for jump" 9 19)

    #+END_SRC

    - 解释器，从里往外，从左往右逐一往外解释执行。

    - 给一个变量赋值 set 和 setq
    #+BEGIN_SRC elisp

  (set 'flowers '(rose viloat a b))
  ;; 两种效果是一样的
  (setq flowers '(rose viloat a b))

(setq count 0)
(setq count (+ count 1))

(message "count is %s" count)

    #+END_SRC

*** 求值实践
    - 相关操作缓冲区的函数

    #+BEGIN_SRC elisp

  (buffer-name)                           ; 获取文件名

  (buffer-file-name)                      ;文件的绝对路径

  (current-buffer)                        ;得到缓冲区本身

  (other-buffer)                          ;最近使用过的缓冲区

  (switch-to-buffer (other-buffer))       ;用来切换到其它某个缓冲区
    #+END_SRC

    - 定位相关函数

    #+BEGIN_SRC elisp
  (buffer-size)                           ;显示buffer 大小，返回当前缓冲区中字符数据计数

  (point)                                 ;光标所在当位置即：'位点'。从这个缓冲区首字符开始到光标所在位置之间的字符数据。

  (point-min)                             ;当前缓冲区位点的最小可能值，这个值一般都是1。

  (point-max)                             ;当前缓冲区位点的最大可能值
    #+END_SRC

*** 如何编写函数定义
    - 函数定义
    1) 符号名，这是函数定义将要依附的符号
    2) 参数列表，如果没有任何参量，就是一个空列表。
    3) 描述这个函数的文档。(C-h f 可以查看到的文档说明。这部分是可选的，推荐使用)
    4) 一个使用函数成为交互函数的表达式，这是可选的。(可以通过M-x 和函数名来使用它或者键入一个适当的键、键序列来使用它)
    5) 函数主体

    #+BEGIN_SRC elisp
  ;; 定义语法
  (defun function-name (arguments...)
  "optional decument..."
  (interactive argument-passing-info)     ;optional
  body...)

    #+END_SRC

    #+BEGIN_SRC elisp

        ;; 简单实例

      (defun one-2-number (number)            ;定义函数
      "1 加其它一个数"
      (+ 1 number))

      (one-2-number 4)                        ; 5

    #+END_SRC

    #+BEGIN_SRC elisp
    ;; 交互式函数

  (defun add-by-serven (number)
  "add by sever function"
  (interactive "p")                       ;定义交互式函数,可以使用 C-u 把数据传递给此函数，具体参数和使用参考《GUN Emacs Lisp 技术手册》
  (message "The result is %d" (+ 7 number)))

  (add-by-serven 98)

    #+END_SRC

    - let 函数定义局部变量
      let 一共有3个部分列表。1, let表达式就是第一个部分。2,变量列表，这个列表的每个元素是一个符号或者一个两元素的列表，它的第一个元素一定是一个符号。3,let表达主体，这个主体由一个或者多个列表组成。
      let 表达式模板如下所示：
      (let varlist body...)

      #+BEGIN_SRC elisp

      (let ((variable value) (varialbe value) ...) body...)

      #+END_SRC

      #+BEGIN_SRC elisp

        (let ((arg1 "zhangsan") (arg2 "lisi"))
        (message "print arg1 is %s,arg2 is %s" arg1 arg2)) ;"print arg1 is zhangsan,arg2 is lisi"

        (let ((arg1 "arch linux") test1 test2 (args2 "ubuntu"))
        (message "all list is %s,%s,%s,%s" arg1 test1 test2 args2)) ;"all list is arch linux,nil,nil,ubuntu"

      #+END_SRC
